<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Netomi API Tester</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #00ff88;
            font-size: 2rem;
        }

        .api-section {
            background-color: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .api-section h2 {
            color: #00ff88;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
            font-weight: bold;
        }

        input, textarea, select {
            width: 100%;
            padding: 10px;
            background-color: #2a2a2a;
            border: 1px solid #555;
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #00ff88;
        }

        input[type="checkbox"] {
            width: auto;
            margin-right: 10px;
        }

        textarea {
            height: 80px;
            resize: vertical;
        }

        button {
            background-color: #00ff88;
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #00cc6a;
        }

        button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        .response {
            margin-top: 15px;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 300px;
            overflow-y: auto;
        }

        .response.success {
            background-color: #0a2f0a;
            border: 1px solid #00ff88;
        }

        .response.error {
            background-color: #2f0a0a;
            border: 1px solid #ff4444;
        }

        .endpoint-info {
            background-color: #2a2a2a;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #aaa;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #333;
            border-radius: 50%;
            border-top-color: #00ff88;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Netomi API Tester</h1>
        
        <!-- Generate Token API -->
        <div class="api-section">
            <h2>1. Generate Token</h2>
            <div class="endpoint-info">GET /api/netomi/generate-token</div>
            <p style="color: #ccc; margin-bottom: 15px;">Calls the external Netomi generate-token API (POST to auth-us.netomi.com) with headers from .env</p>
            
            <button id="generateTokenBtn" onclick="generateToken()">Generate Token</button>
            <div id="generateTokenResponse" class="response" style="display: none;"></div>
        </div>

        <!-- Refresh Token API -->
        <div class="api-section">
            <h2>2. Refresh Token</h2>
            <div class="endpoint-info">POST /api/netomi/refresh-token</div>
            <p style="color: #ccc; margin-bottom: 15px;">Calls the external Netomi refresh-token API (POST to auth-us.netomi.com) with headers from .env</p>
            
            <div class="form-group">
                <label for="refreshTokenInput">Refresh Token *</label>
                <textarea id="refreshTokenInput" placeholder="Enter your refresh token here..." required></textarea>
            </div>
            
            <button id="refreshTokenBtn" onclick="refreshToken()">Refresh Token</button>
            <div id="refreshTokenResponse" class="response" style="display: none;"></div>
        </div>

        <!-- Process Message API -->
        <div class="api-section">
            <h2>3. Process Message</h2>
            <div class="endpoint-info">POST /api/netomi/process-message</div>
            <p style="color: #ccc; margin-bottom: 15px;">Calls the external Netomi process-message API (POST to aiapi-us.netomi.com) with headers from .env</p>
            
            <div class="form-group">
                <label for="authToken">Auth Token *</label>
                <input type="text" id="authToken" placeholder="Enter your auth token here..." required>
            </div>
            
            <div class="form-group">
                <label for="conversationId">Conversation ID *</label>
                <input type="text" id="conversationId" placeholder="Enter conversation ID..." required>
            </div>
            
            <div class="form-group">
                <label for="messageText">Message Text *</label>
                <textarea id="messageText" placeholder="Enter the message text..." required></textarea>
            </div>
            
            <div class="form-group">
                <label for="userId">User ID *</label>
                <input type="text" id="userId" placeholder="Enter user ID..." required>
            </div>
            
            <div class="form-group">
                <label for="messageId">Message ID (optional)</label>
                <input type="text" id="messageId" placeholder="Leave empty for auto-generated UUID">
            </div>
            
            <div class="form-group">
                <label for="ownerType">Owner Type</label>
                <select id="ownerType">
                    <option value="BOT">BOT</option>
                    <option value="USER">USER</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="origin">Origin</label>
                <select id="origin">
                    <option value="WEB">WEB</option>
                    <option value="MOBILE">MOBILE</option>
                    <option value="API">API</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="hideMessage">Hide Message</label>
                <input type="checkbox" id="hideMessage" checked>
            </div>
            
            <div class="form-group">
                <label for="waitForWebhook">Wait for Webhook Response</label>
                <input type="checkbox" id="waitForWebhook" checked>
                <small style="color: #aaa; display: block; margin-top: 5px;">If checked, waits for the AI response via webhook. If unchecked, returns only acknowledgment.</small>
            </div>
            
            <div class="form-group">
                <label for="webhookTimeout">Webhook Timeout (seconds)</label>
                <input type="number" id="webhookTimeout" value="30" min="5" max="120">
                <small style="color: #aaa; display: block; margin-top: 5px;">How long to wait for webhook response before timing out.</small>
            </div>
            
            <button id="processMessageBtn" onclick="processMessage()">Process Message</button>
            <div id="processMessageResponse" class="response" style="display: none;"></div>
        </div>

        <!-- Webhook Messages Display -->
        <div class="api-section">
            <h2>4. Webhook Messages</h2>
            <div class="endpoint-info">Real-time webhook messages from Netomi</div>
            <p style="color: #ccc; margin-bottom: 15px;">This section displays messages received at the /webhook/netomi endpoint in real-time</p>
            
            <div class="form-group">
                <label>
                    <input type="checkbox" id="autoRefreshWebhook" checked> Auto-refresh webhook messages (every 5 seconds)
                </label>
            </div>
            
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <button onclick="refreshWebhookMessages()">Refresh Now</button>
                <button onclick="clearWebhookMessages()">Clear Messages</button>
                <button onclick="toggleWebhookInfo()">Show Webhook Info</button>
            </div>
            
            <div id="webhookInfo" class="endpoint-info" style="display: none; margin-bottom: 15px;">
                <div><strong>Webhook URL:</strong> <span id="webhookUrl">Loading...</span></div>
                <div><strong>Bearer Token:</strong> <span id="webhookToken">Loading...</span></div>
                <div><strong>Test Command:</strong> <span id="webhookTestCmd" style="font-size: 11px; word-break: break-all;">Loading...</span></div>
            </div>
            
            <div id="webhookMessagesContainer">
                <div id="webhookMessages" class="response" style="display: block; min-height: 200px; max-height: 400px;">
                    <div style="color: #666; text-align: center; padding: 20px;">
                        📡 Waiting for webhook messages...<br>
                        <small>Send a message using the Process Message section above to see webhook responses here.</small>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 10px; font-size: 12px; color: #666;">
                Last updated: <span id="webhookLastUpdate">Never</span>
                <span id="webhookStatus" style="margin-left: 10px;">⚪ Idle</span>
            </div>
        </div>

    </div>

    <script>
        // Function to sanitize HTML content to prevent XSS
        function sanitizeHtml(str) {
            if (typeof str !== 'string') {
                str = String(str);
            }
            return str
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#x27;')
                .replace(/\//g, '&#x2F;');
        }

        // Function to sanitize URL to prevent XSS in href attributes
        function sanitizeUrl(url) {
            if (typeof url !== 'string') {
                return '#';
            }
            // Only allow http/https URLs
            if (url.match(/^https?:\/\//)) {
                return sanitizeHtml(url);
            }
            return '#';
        }

        // Function to format Process Message response with enhanced display
        function formatProcessMessageResponse(data) {
            let html = '<div style="font-family: monospace;">';
            
            // Basic response info
            html += '<div style="color: #00ff88; font-weight: bold; margin-bottom: 10px;">✓ Process Message Response</div>';
            
            // Show acknowledgment info
            if (data.data && data.data.acknowledgment) {
                html += '<div style="margin-bottom: 15px;">';
                html += '<div style="color: #ffa500; font-weight: bold; margin-bottom: 8px;">📬 Acknowledgment:</div>';
                html += '<div style="background: #1a1a1a; padding: 8px; border-radius: 4px;">';
                html += `<div><strong>Status:</strong> Message sent to Netomi</div>`;
                if (data.data.acknowledgment.requestId) {
                    html += `<div><strong>Request ID:</strong> ${sanitizeHtml(data.data.acknowledgment.requestId)}</div>`;
                }
                html += '</div></div>';
            }
            
            // Show webhook response if available
            if (data.data && data.data.webhookResponse) {
                html += '<div style="margin-bottom: 15px;">';
                html += '<div style="color: #00ff88; font-weight: bold; margin-bottom: 8px;">🚀 Webhook Response (AI Payload):</div>';
                
                // Check for different response formats
                const webhook = data.data.webhookResponse;
                
                // Check if we have attachments (Netomi AI responses)
                if (webhook.attachments && webhook.attachments.length > 0) {
                    webhook.attachments.forEach((attachment, index) => {
                        if (attachment.type === 'ai.msg.domain.responses.core.MultiSource') {
                            html += formatMultiSourceAttachment(attachment.attachment);
                        } else if (attachment.type === 'ai.msg.domain.responses.core.Text') {
                            html += formatTextAttachment(attachment.attachment);
                        }
                    });
                }
                
                // Show message content if available
                if (webhook.message || webhook.messagePayload) {
                    const message = webhook.message || webhook.messagePayload;
                    html += '<div style="background: #0a2f0a; border: 1px solid #00ff88; padding: 10px; border-radius: 4px; margin-bottom: 10px;">';
                    html += '<div style="color: #00ff88; font-weight: bold; margin-bottom: 8px;">💬 AI Message:</div>';
                    html += `<div style="background: #1a1a1a; padding: 8px; border-radius: 4px;">${sanitizeHtml(message.text || message.content || JSON.stringify(message))}</div>`;
                    html += '</div>';
                }
                
                // Show conversation info
                if (webhook.conversationId) {
                    html += '<div style="margin-bottom: 15px;">';
                    html += '<div style="color: #20b2aa; font-weight: bold; margin-bottom: 8px;">💼 Conversation Info:</div>';
                    html += '<div style="background: #1a1a1a; padding: 8px; border-radius: 4px;">';
                    html += `<div><strong>Conversation ID:</strong> ${sanitizeHtml(webhook.conversationId)}</div>`;
                    if (webhook.userId) html += `<div><strong>User ID:</strong> ${sanitizeHtml(webhook.userId)}</div>`;
                    if (webhook.botId) html += `<div><strong>Bot ID:</strong> ${sanitizeHtml(webhook.botId)}</div>`;
                    html += '</div></div>';
                }
                
                html += '</div>';
            } else if (data.data && data.data.error) {
                // Show timeout/error message
                html += '<div style="margin-bottom: 15px;">';
                html += '<div style="color: #ff6b6b; font-weight: bold; margin-bottom: 8px;">⏰ Webhook Status:</div>';
                html += '<div style="background: #2f0a0a; border: 1px solid #ff6b6b; padding: 10px; border-radius: 4px;">';
                html += `<div><strong>Status:</strong> ${sanitizeHtml(data.data.error)}</div>`;
                html += '<div><strong>Note:</strong> Only acknowledgment received. You can check for responses later using the conversation API.</div>';
                if (data.data.requestId) {
                    html += `<div><strong>Request ID:</strong> ${sanitizeHtml(data.data.requestId)}</div>`;
                }
                html += '</div></div>';
            }
            
            // Request info
            if (data.data && data.data.requestPayload) {
                html += '<div style="margin-bottom: 15px;">';
                html += '<div style="color: #ffa500; font-weight: bold; margin-bottom: 8px;">📝 Request Info:</div>';
                html += '<div style="background: #1a1a1a; padding: 8px; border-radius: 4px;">';
                html += `<div><strong>Message:</strong> "${sanitizeHtml(data.data.requestPayload.messagePayload?.text || 'N/A')}"</div>`;
                html += `<div><strong>User ID:</strong> ${sanitizeHtml(data.data.requestPayload.userDetails?.userId || 'N/A')}</div>`;
                html += `<div><strong>Conversation ID:</strong> ${sanitizeHtml(data.data.requestPayload.conversationId || 'N/A')}</div>`;
                html += '</div></div>';
            }
            
            // Custom fields
            if (data.data && data.data.customFields) {
                html += '<div style="margin-bottom: 15px;">';
                html += '<div style="color: #9370db; font-weight: bold; margin-bottom: 8px;">⚙️ Custom Fields:</div>';
                html += '<div style="background: #1a1a1a; padding: 8px; border-radius: 4px;">';
                Object.entries(data.data.customFields).forEach(([key, value]) => {
                    html += `<div><strong>${sanitizeHtml(key)}:</strong> ${sanitizeHtml(value)}</div>`;
                });
                html += '</div></div>';
            }
            
            // Raw JSON (collapsible)
            html += '<details style="margin-top: 15px;">';
            html += '<summary style="color: #666; cursor: pointer;">📋 Show Raw JSON Response</summary>';
            html += '<pre style="background: #0a0a0a; padding: 10px; border-radius: 4px; margin-top: 8px; overflow-x: auto; font-size: 11px;">';
            html += JSON.stringify(data, null, 2);
            html += '</pre></details>';
            
            html += '</div>';
            return html;
        }
        
        function formatMultiSourceAttachment(attachment) {
            let html = '<div style="background: #0a2f0a; border: 1px solid #00ff88; padding: 10px; border-radius: 4px; margin-bottom: 10px;">';
            html += '<div style="color: #00ff88; font-weight: bold; margin-bottom: 8px;">📚 Knowledge Base Sources:</div>';
            
            if (attachment.multipleSourceDetails && attachment.multipleSourceDetails.length > 0) {
                attachment.multipleSourceDetails.forEach((source, index) => {
                    html += '<div style="margin-bottom: 5px;">';
                    html += `<span style="color: #00ff88; font-weight: bold;">${sanitizeHtml(source.index || index + 1)}.</span> `;
                    html += `<a href="${sanitizeUrl(source.text)}" target="_blank" style="color: #87ceeb; text-decoration: none;">${sanitizeHtml(source.text)}</a>`;
                    if (source.uuid) {
                        html += ` <span style="color: #666; font-size: 10px;">(${sanitizeHtml(source.uuid.substring(0, 8))}...)</span>`;
                    }
                    html += '</div>';
                });
            }
            
            html += '</div>';
            return html;
        }
        
        function formatTextAttachment(attachment) {
            let html = '<div style="background: #0a2f2f; border: 1px solid #20b2aa; padding: 10px; border-radius: 4px; margin-bottom: 10px;">';
            html += '<div style="color: #20b2aa; font-weight: bold; margin-bottom: 8px;">💬 AI Text Response:</div>';
            
            if (attachment.text) {
                html += `<div style="background: #1a1a1a; padding: 8px; border-radius: 4px;">${sanitizeHtml(attachment.text)}</div>`;
            }
            
            if (attachment.sourceUrl) {
                html += '<div style="margin-top: 8px;">';
                html += '<span style="color: #20b2aa; font-weight: bold;">Source: </span>';
                html += `<a href="${sanitizeUrl(attachment.sourceUrl)}" target="_blank" style="color: #87ceeb; text-decoration: none;">${sanitizeHtml(attachment.sourceUrl)}</a>`;
                html += '</div>';
            }
            
            html += '</div>';
            return html;
        }

        // Generate Token API Call
        async function generateToken() {
            const btn = document.getElementById('generateTokenBtn');
            const responseDiv = document.getElementById('generateTokenResponse');
            
            btn.disabled = true;
            btn.innerHTML = 'Generating Token<span class="loading"></span>';
            responseDiv.style.display = 'none';
            
            try {
                const response = await fetch('/api/netomi/generate-token');
                const data = await response.json();
                
                responseDiv.style.display = 'block';
                responseDiv.className = 'response ' + (data.ok ? 'success' : 'error');
                responseDiv.textContent = JSON.stringify(data, null, 2);
                
                // Auto-fill Process Message section if token generation was successful
                if (data.ok && data.data && data.data.payload && data.data.payload.token) {
                    // Fill in the auth token
                    document.getElementById('authToken').value = data.data.payload.token;
                    
                    // Fill in refresh token input if available
                    if (data.data.payload.refreshToken) {
                        document.getElementById('refreshTokenInput').value = data.data.payload.refreshToken;
                    }
                    
                    // Show success message
                    console.log('Auto-filled Process Message section with generated token');
                    
                    // Also auto-fill Send Message section with available data
                    // Note: Send Message doesn't use auth token, but we can fill user/session info
                    
                    // Optional: Show a visual indicator that fields were auto-filled
                    const authTokenField = document.getElementById('authToken');
                    authTokenField.style.borderColor = '#00ff88';
                    authTokenField.style.boxShadow = '0 0 5px rgba(0, 255, 136, 0.3)';
                    setTimeout(() => {
                        authTokenField.style.borderColor = '#555';
                        authTokenField.style.boxShadow = 'none';
                    }, 2000);
                }
                
            } catch (error) {
                responseDiv.style.display = 'block';
                responseDiv.className = 'response error';
                responseDiv.textContent = 'Network Error: ' + error.message;
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'Generate Token';
            }
        }

        // Refresh Token API Call
        async function refreshToken() {
            const btn = document.getElementById('refreshTokenBtn');
            const responseDiv = document.getElementById('refreshTokenResponse');
            
            const refreshTokenValue = document.getElementById('refreshTokenInput').value.trim();
            if (!refreshTokenValue) {
                alert('Refresh token is required!');
                return;
            }
            
            btn.disabled = true;
            btn.innerHTML = 'Refreshing Token<span class="loading"></span>';
            responseDiv.style.display = 'none';
            
            try {
                const response = await fetch('/api/netomi/refresh-token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        refreshToken: refreshTokenValue
                    })
                });
                
                const data = await response.json();
                
                responseDiv.style.display = 'block';
                responseDiv.className = 'response ' + (data.ok ? 'success' : 'error');
                responseDiv.textContent = JSON.stringify(data, null, 2);
                
                // Auto-fill Process Message section if refresh token was successful
                if (data.ok && data.data && data.data.payload && data.data.payload.token) {
                    // Fill in the auth token with the new token
                    document.getElementById('authToken').value = data.data.payload.token;
                    
                    // Show success message
                    console.log('Auto-filled Process Message section with refreshed token');
                    
                    // Visual indicator
                    const authTokenField = document.getElementById('authToken');
                    authTokenField.style.borderColor = '#00ff88';
                    authTokenField.style.boxShadow = '0 0 5px rgba(0, 255, 136, 0.3)';
                    setTimeout(() => {
                        authTokenField.style.borderColor = '#555';
                        authTokenField.style.boxShadow = 'none';
                    }, 2000);
                }
                
            } catch (error) {
                responseDiv.style.display = 'block';
                responseDiv.className = 'response error';
                responseDiv.textContent = 'Network Error: ' + error.message;
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'Refresh Token';
            }
        }

        // Process Message API Call
        async function processMessage() {
            const btn = document.getElementById('processMessageBtn');
            const responseDiv = document.getElementById('processMessageResponse');
            
            const authToken = document.getElementById('authToken').value.trim();
            if (!authToken) {
                alert('Auth token is required!');
                return;
            }
            
            const conversationId = document.getElementById('conversationId').value.trim();
            if (!conversationId) {
                alert('Conversation ID is required!');
                return;
            }
            
            const messageText = document.getElementById('messageText').value.trim();
            if (!messageText) {
                alert('Message text is required!');
                return;
            }
            
            const userId = document.getElementById('userId').value.trim();
            if (!userId) {
                alert('User ID is required!');
                return;
            }
            
            // Build message data from form inputs
            const messageData = {
                conversationId: conversationId,
                messagePayload: {
                    text: messageText,
                    label: "",
                    messageId: document.getElementById('messageId').value.trim() || crypto.randomUUID(),
                    timestamp: Date.now(), // Use milliseconds, not seconds
                    hideMessage: document.getElementById('hideMessage').checked
                },
                userDetails: {
                    userId: userId
                },
                origin: document.getElementById('origin').value,
                eventType: "message",
                additionalAttributes: {
                    CUSTOM_ATTRIBUTES: [
                        {
                            type: "TEXT",
                            name: "widget_id",
                            value: "",
                            scope: "LIFE_TIME"
                        },
                        {
                            type: "TEXT",
                            name: "visitor_url",
                            value: window.location.href,
                            scope: "LIFE_TIME"
                        },
                        {
                            type: "TEXT",
                            name: "current_user_agent",
                            value: navigator.userAgent,
                            scope: "LIFE_TIME"
                        },
                        {
                            type: "TEXT",
                            name: "current_device_type",
                            value: /Mobile|Android|iPhone|iPad/.test(navigator.userAgent) ? "mobile" : "desktop",
                            scope: "LIFE_TIME"
                        },
                        {
                            type: "TEXT",
                            name: "current_platform",
                            value: navigator.platform,
                            scope: "LIFE_TIME"
                        }
                    ]
                }
            };
            
            // Get webhook settings
            const waitForWebhook = document.getElementById('waitForWebhook').checked;
            const webhookTimeout = parseInt(document.getElementById('webhookTimeout').value) * 1000; // Convert to milliseconds
            
            btn.disabled = true;
            btn.innerHTML = waitForWebhook ? 'Processing Message & Waiting for AI Response<span class="loading"></span>' : 'Processing Message<span class="loading"></span>';
            responseDiv.style.display = 'none';
            
            try {
                const response = await fetch('/api/netomi/process-message', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        authToken: authToken,
                        messageData: messageData,
                        waitForWebhook: waitForWebhook,
                        timeoutMs: webhookTimeout
                    })
                });
                
                const data = await response.json();
                
                responseDiv.style.display = 'block';
                responseDiv.className = 'response ' + (data.ok ? 'success' : 'error');
                
                // Enhanced display for Process Message responses
                if (data.ok && data.data) {
                    responseDiv.innerHTML = formatProcessMessageResponse(data);
                } else {
                    responseDiv.textContent = JSON.stringify(data, null, 2);
                }
                
                
            } catch (error) {
                responseDiv.style.display = 'block';
                responseDiv.className = 'response error';
                responseDiv.textContent = 'Network Error: ' + error.message;
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'Process Message';
            }
        }


        // Webhook Messages Management
        let webhookRefreshInterval = null;
        let lastWebhookMessageCount = 0;

        // Store webhook messages in memory for this session
        let webhookMessages = [];

        // Auto-refresh webhook messages
        function startWebhookAutoRefresh() {
            if (document.getElementById('autoRefreshWebhook').checked) {
                webhookRefreshInterval = setInterval(refreshWebhookMessages, 5000);
                document.getElementById('webhookStatus').textContent = '🔄 Auto-refreshing';
                document.getElementById('webhookStatus').style.color = '#00ff88';
            } else {
                if (webhookRefreshInterval) {
                    clearInterval(webhookRefreshInterval);
                    webhookRefreshInterval = null;
                }
                document.getElementById('webhookStatus').textContent = '⚪ Manual';
                document.getElementById('webhookStatus').style.color = '#666';
            }
        }

        // Toggle auto-refresh when checkbox changes
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('autoRefreshWebhook').addEventListener('change', startWebhookAutoRefresh);
            startWebhookAutoRefresh();
            loadWebhookInfo();
        });

        // Load webhook configuration info
        async function loadWebhookInfo() {
            try {
                const response = await fetch('/webhook/info');
                const data = await response.json();
                
                document.getElementById('webhookUrl').textContent = data.webhook_endpoint;
                document.getElementById('webhookToken').textContent = data.bearer_token;
                document.getElementById('webhookTestCmd').textContent = data.test_command;
            } catch (error) {
                console.error('Failed to load webhook info:', error);
            }
        }

        // Toggle webhook info display
        function toggleWebhookInfo() {
            const infoDiv = document.getElementById('webhookInfo');
            const isHidden = infoDiv.style.display === 'none';
            infoDiv.style.display = isHidden ? 'block' : 'none';
            
            const button = event.target;
            button.textContent = isHidden ? 'Hide Webhook Info' : 'Show Webhook Info';
        }

        // Refresh webhook messages from server
        async function refreshWebhookMessages() {
            try {
                document.getElementById('webhookStatus').textContent = '🔄 Refreshing...';
                document.getElementById('webhookStatus').style.color = '#ffa500';
                
                // Fetch webhook messages from server
                const response = await fetch('/api/webhook-messages?limit=50');
                const data = await response.json();
                
                if (data.success) {
                    displayWebhookMessages(data.messages);
                    document.getElementById('webhookLastUpdate').textContent = new Date().toLocaleTimeString();
                    document.getElementById('webhookStatus').textContent = document.getElementById('autoRefreshWebhook').checked ? '🔄 Auto-refreshing' : '✅ Updated';
                    document.getElementById('webhookStatus').style.color = '#00ff88';
                } else {
                    throw new Error('Failed to fetch webhook messages');
                }
                
            } catch (error) {
                console.error('Failed to refresh webhook messages:', error);
                document.getElementById('webhookStatus').textContent = '❌ Error';
                document.getElementById('webhookStatus').style.color = '#ff4444';
                
                // Fallback to localStorage if server fails
                const fallbackMessages = getStoredWebhookMessages();
                displayWebhookMessages(fallbackMessages);
            }
        }

        // Display webhook messages in the UI
        function displayWebhookMessages(messages) {
            const container = document.getElementById('webhookMessages');
            
            if (!messages || messages.length === 0) {
                container.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">📡 No webhook messages received yet.<br><small>Send a message using the Process Message section to see webhook responses here.</small></div>';
                return;
            }

            // Store the current state of expanded details elements
            const openDetails = new Set();
            const existingDetails = container.querySelectorAll('details[open]');
            existingDetails.forEach((detail, index) => {
                // Create a unique identifier for each detail element
                const messageIndex = detail.closest('[data-message-index]')?.getAttribute('data-message-index');
                if (messageIndex) {
                    openDetails.add(messageIndex);
                }
            });

            let html = '<div style="font-family: monospace;">';
            
            // Sort messages by timestamp (newest first)
            messages.sort((a, b) => b.timestamp - a.timestamp);
            
            messages.forEach((msg, index) => {
                const date = new Date(msg.timestamp);
                const timeStr = date.toLocaleTimeString();
                const dateStr = date.toLocaleDateString();
                const messageIndex = messages.length - index; // Unique identifier for this message
                
                html += `<div data-message-index="${messageIndex}" style="border-bottom: 1px solid #333; padding: 10px 0; ${index === 0 ? 'border-top: 1px solid #333;' : ''}">`;
                html += `<div style="color: #00ff88; font-weight: bold; margin-bottom: 5px;">📨 Webhook Message #${messageIndex}</div>`;
                html += `<div style="color: #666; font-size: 11px; margin-bottom: 8px;">${timeStr} - ${dateStr}</div>`;
                
                // Format the webhook payload
                if (msg.data) {
                    // Show conversation ID if available
                    if (msg.data.conversationId) {
                        html += `<div style="margin-bottom: 5px;"><strong>Conversation ID:</strong> ${msg.data.conversationId}</div>`;
                    }
                    
                    // Show trigger type
                    if (msg.data.triggerType) {
                        html += `<div style="margin-bottom: 5px;"><strong>Trigger Type:</strong> ${msg.data.triggerType}</div>`;
                    }
                    
                    // Extract and display AI response text and carousels from Netomi payload
                    let aiResponseText = null;
                    let userRequestText = null;
                    let carouselData = null;
                    
                    if (msg.data.attachments && Array.isArray(msg.data.attachments)) {
                        // Look for AI response in attachments
                        msg.data.attachments.forEach(attachment => {
                            if (attachment.attachment && attachment.attachment.attachmentResponseType === "ANSWER_AI_RESPONSE") {
                                // Text response
                                if (attachment.attachment.text && attachment.attachment.text.trim() !== "") {
                                    aiResponseText = attachment.attachment.text;
                                }
                                // Carousel response
                                if (attachment.type === "ai.msg.domain.responses.core.Carousel" && 
                                    attachment.attachment.elements && 
                                    attachment.attachment.elements.length > 0) {
                                    carouselData = attachment.attachment;
                                }
                            }
                        });
                    }
                    
                    // Extract user request text
                    if (msg.data.requestPayload && msg.data.requestPayload.messagePayload && msg.data.requestPayload.messagePayload.text) {
                        userRequestText = msg.data.requestPayload.messagePayload.text;
                    }
                    
                    // Display user request (what user asked)
                    if (userRequestText) {
                        html += `<div style="background: #1a1a2a; border: 1px solid #4a90e2; padding: 8px; border-radius: 4px; margin: 8px 0;">`;
                        html += `<div style="color: #4a90e2; font-weight: bold; margin-bottom: 5px;">👤 User Request:</div>`;
                        html += `<div style="font-style: italic;">"${userRequestText}"</div>`;
                        html += `</div>`;
                    }
                    
                    // Display AI response prominently
                    if (aiResponseText) {
                        html += `<div style="background: #0a2f0a; border: 2px solid #00ff88; padding: 12px; border-radius: 8px; margin: 8px 0; box-shadow: 0 0 10px rgba(0, 255, 136, 0.2);">`;
                        html += `<div style="color: #00ff88; font-weight: bold; margin-bottom: 8px; font-size: 14px;">🤖 Netomi AI Response:</div>`;
                        html += `<div style="background: #1a1a1a; padding: 10px; border-radius: 4px; font-size: 14px; line-height: 1.4; color: #ffffff;">"${aiResponseText}"</div>`;
                        html += `</div>`;
                    }
                    
                    // Display Carousel with Images
                    if (carouselData) {
                        html += `<div style="background: #0a2f2f; border: 2px solid #20b2aa; padding: 12px; border-radius: 8px; margin: 8px 0; box-shadow: 0 0 10px rgba(32, 178, 170, 0.2);">`;
                        html += `<div style="color: #20b2aa; font-weight: bold; margin-bottom: 12px; font-size: 14px;">🛍️ Product Carousel (${carouselData.elements.length} items):</div>`;
                        
                        // Carousel container with horizontal scroll
                        html += `<div style="display: flex; gap: 12px; overflow-x: auto; padding: 8px 0; margin-bottom: 8px;">`;
                        
                        carouselData.elements.forEach((element, elementIndex) => {
                            html += `<div style="flex: none; width: 200px; background: #1a1a1a; border-radius: 8px; overflow: hidden; border: 1px solid #333;">`;
                            
                            // Product image
                            if (element.imageUrl) {
                                html += `<div style="position: relative; width: 100%; height: 150px; background: #2a2a2a;">`;
                                html += `<img src="${element.imageUrl}" alt="${element.title || 'Product'}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 0;" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">`;
                                html += `<div style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #2a2a2a; align-items: center; justify-content: center; color: #666; font-size: 12px;">📷 Image unavailable</div>`;
                                html += `</div>`;
                            }
                            
                            // Product details
                            html += `<div style="padding: 12px;">`;
                            
                            // Title
                            if (element.title) {
                                html += `<div style="color: #ffffff; font-weight: bold; margin-bottom: 6px; font-size: 13px; line-height: 1.3;">${sanitizeHtml(element.title)}</div>`;
                            }
                            
                            // Description
                            if (element.description && element.description !== element.title) {
                                html += `<div style="color: #ccc; font-size: 11px; margin-bottom: 8px; line-height: 1.3;">${sanitizeHtml(element.description)}</div>`;
                            }
                            
                            // Buttons
                            if (element.buttons && element.buttons.length > 0) {
                                element.buttons.forEach(button => {
                                    if (button.type === "WEB" && button.url) {
                                        html += `<a href="${sanitizeUrl(button.url)}" target="_blank" style="display: inline-block; background: #20b2aa; color: #000; padding: 6px 10px; border-radius: 4px; text-decoration: none; font-size: 11px; font-weight: bold; margin-top: 4px; transition: background-color 0.3s;">${sanitizeHtml(button.title || 'View Details')}</a>`;
                                    }
                                });
                            }
                            
                            html += `</div>`; // Close product details
                            html += `</div>`; // Close product card
                        });
                        
                        html += `</div>`; // Close carousel container
                        
                        // Carousel info
                        html += `<div style="font-size: 11px; color: #666; margin-top: 8px;">`;
                        html += `Aspect Ratio: ${sanitizeHtml(carouselData.carouselImageAspectRatio || 'N/A')} | `;
                        html += `Items: ${carouselData.elements.length} | `;
                        html += `Scroll horizontally to see all items`;
                        html += `</div>`;
                        
                        html += `</div>`; // Close carousel container
                    }
                    
                    // Show other message content (fallback)
                    if (!aiResponseText && msg.data.message) {
                        html += `<div style="background: #0a2f0a; border: 1px solid #00ff88; padding: 8px; border-radius: 4px; margin: 8px 0;">`;
                        html += `<div style="color: #00ff88; font-weight: bold; margin-bottom: 5px;">💬 Message:</div>`;
                        html += `<div>${sanitizeHtml(typeof msg.data.message === 'string' ? msg.data.message : JSON.stringify(msg.data.message))}</div>`;
                        html += `</div>`;
                    }
                    
                    // Show test messages
                    if (msg.data.test) {
                        html += `<div style="background: #2a2a0a; border: 1px solid #ffa500; padding: 8px; border-radius: 4px; margin: 8px 0;">`;
                        html += `<div style="color: #ffa500; font-weight: bold;">🧪 Test Message: ${sanitizeHtml(msg.data.test)}</div>`;
                        html += `</div>`;
                    }
                    
                    // Show additional response details
                    if (msg.data.customFields) {
                        html += `<div style="margin-top: 8px; font-size: 11px; color: #666;">`;
                        if (msg.data.customFields.CHUNK_STATUS) {
                            html += `<span style="margin-right: 10px;">Status: ${sanitizeHtml(msg.data.customFields.CHUNK_STATUS)}</span>`;
                        }
                        if (msg.data.customFields.TRANSLATE_LANGUAGE) {
                            html += `<span style="margin-right: 10px;">Language: ${sanitizeHtml(msg.data.customFields.TRANSLATE_LANGUAGE)}</span>`;
                        }
                        html += `</div>`;
                    }
                }
                
                // Collapsible raw data with preserved state
                const isOpen = openDetails.has(messageIndex.toString());
                html += `<details ${isOpen ? 'open' : ''} style="margin-top: 8px;">`;
                html += `<summary style="color: #666; cursor: pointer; font-size: 11px;">📋 Raw Data</summary>`;
                html += `<pre style="background: #0a0a0a; padding: 8px; border-radius: 4px; margin-top: 5px; overflow-x: auto; font-size: 10px;">${sanitizeHtml(JSON.stringify(msg.data, null, 2))}</pre>`;
                html += `</details>`;
                
                html += `</div>`;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }

        // Store webhook message (called when a webhook is received)
        function storeWebhookMessage(data) {
            const message = {
                timestamp: Date.now(),
                data: data
            };
            
            // Get existing messages from localStorage
            let stored = getStoredWebhookMessages();
            stored.push(message);
            
            // Keep only last 50 messages
            if (stored.length > 50) {
                stored = stored.slice(-50);
            }
            
            // Store back to localStorage
            localStorage.setItem('webhookMessages', JSON.stringify(stored));
            
            // Update display if auto-refresh is on
            if (document.getElementById('autoRefreshWebhook').checked) {
                displayWebhookMessages(stored);
                document.getElementById('webhookLastUpdate').textContent = new Date().toLocaleTimeString();
            }
        }

        // Get stored webhook messages from localStorage
        function getStoredWebhookMessages() {
            try {
                const stored = localStorage.getItem('webhookMessages');
                return stored ? JSON.parse(stored) : [];
            } catch (error) {
                console.error('Failed to parse stored webhook messages:', error);
                return [];
            }
        }

        // Clear webhook messages
        function clearWebhookMessages() {
            if (confirm('Are you sure you want to clear all webhook messages?')) {
                // Clear from localStorage and display
                localStorage.removeItem('webhookMessages');
                displayWebhookMessages([]);
                document.getElementById('webhookLastUpdate').textContent = 'Cleared (localStorage only)';
                
                // Note: Server-side messages are not cleared - they will reappear on refresh
                // In a real implementation, you might want to add a server endpoint to clear messages
            }
        }

        // Simulate receiving a webhook message (for testing)
        function simulateWebhookMessage() {
            const testMessage = {
                conversationId: 'test-' + Date.now(),
                triggerType: 'RESPONSE',
                message: 'This is a simulated webhook message for testing purposes.',
                timestamp: new Date().toISOString(),
                test: true
            };
            
            storeWebhookMessage(testMessage);
        }

        // Pre-fill process message form with sample data from curl
        document.getElementById('conversationId').value = '7f4b29a1-c38d-420e-b3c9-94f8fdc112f9';
        document.getElementById('messageText').value = 'How much time do I have to return something ? Where are the stores located';
        document.getElementById('userId').value = '5113d6d7';
        document.getElementById('messageId').value = 'd1f5a809-f20f-40e1-89cd-e8b9384d0dc7';
        document.getElementById('ownerType').value = 'BOT';
        document.getElementById('origin').value = 'WEB';
        document.getElementById('hideMessage').checked = true;
    </script>
</body>
</html>
